{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Crystalball \u00b6 Crystalball is a Ruby library which implements Regression Test Selection mechanism originally published by Aaron Patterson. Its main purpose is to select a minimal subset of your test suite which should be run to ensure your changes didn't break anything. Installation \u00b6 Please check our installation instructions . Basic Usage \u00b6 Start MapGenerator in your spec_helper before you loaded any file of your app. E.g. if ENV['CRYSTALBALL'] == 'true' Crystalball::MapGenerator.start! do |config| config.register Crystalball::MapGenerator::CoverageStrategy.new end end Run your test suite with Crystaball enabled on clean master branch with green build. CRYSTALBALL=true bundle exec rspec . This step will generate file tmp/crystalball_data.yml in your project root. This file contains useful profiling data for Crystalball. Make some changes to your app code Run bundle exec crystalball to build a prediction and run RSpec with it. Check out RSpec runner section for customization details. Keep in mind that as your target branch (usually master) code changes your execution maps will become outdated, so you need to regenerate execution maps regularly. Advanced Usage \u00b6 Crystalball workflow can be divided into 2 parts. 1. Full build profiling where Crystalball gathers some data about your RSpec suite for later use in predictions. This is where map generators do their job. 2. Actual predicting where Crystalball uses profiling info from step above and tries to get best prediction possible. This is where predictors do their job. Both of these steps can be heavily customized and enchanted based on your project specifics and your needs. You might want to check: map generators docs for details related to suite profiling. predictors docs for details related to actual prediction. runner docs for runner configuration details. Spring integration \u00b6 It's very easy to integrate Crystalball with Spring . Check out spring-commands-crystalball for details.","title":"Home"},{"location":"#crystalball","text":"Crystalball is a Ruby library which implements Regression Test Selection mechanism originally published by Aaron Patterson. Its main purpose is to select a minimal subset of your test suite which should be run to ensure your changes didn't break anything.","title":"Crystalball"},{"location":"#installation","text":"Please check our installation instructions .","title":"Installation"},{"location":"#basic-usage","text":"Start MapGenerator in your spec_helper before you loaded any file of your app. E.g. if ENV['CRYSTALBALL'] == 'true' Crystalball::MapGenerator.start! do |config| config.register Crystalball::MapGenerator::CoverageStrategy.new end end Run your test suite with Crystaball enabled on clean master branch with green build. CRYSTALBALL=true bundle exec rspec . This step will generate file tmp/crystalball_data.yml in your project root. This file contains useful profiling data for Crystalball. Make some changes to your app code Run bundle exec crystalball to build a prediction and run RSpec with it. Check out RSpec runner section for customization details. Keep in mind that as your target branch (usually master) code changes your execution maps will become outdated, so you need to regenerate execution maps regularly.","title":"Basic Usage"},{"location":"#advanced-usage","text":"Crystalball workflow can be divided into 2 parts. 1. Full build profiling where Crystalball gathers some data about your RSpec suite for later use in predictions. This is where map generators do their job. 2. Actual predicting where Crystalball uses profiling info from step above and tries to get best prediction possible. This is where predictors do their job. Both of these steps can be heavily customized and enchanted based on your project specifics and your needs. You might want to check: map generators docs for details related to suite profiling. predictors docs for details related to actual prediction. runner docs for runner configuration details.","title":"Advanced Usage"},{"location":"#spring-integration","text":"It's very easy to integrate Crystalball with Spring . Check out spring-commands-crystalball for details.","title":"Spring integration"},{"location":"map_generators/","text":"Map generators \u00b6 Execution Map Generator \u00b6 There are different map generator strategies that can (and should) be used together for better predictions. Each one has its own benefits and drawbacks, so they should be configured to best fit your needs. Custom map file name \u00b6 You can customize resulting map filename with map_storage_path value. E.g. Crystalball :: MapGenerator . start! do | config | #... config . map_storage_path = \"execution_map_ #{ ENV [ 'TEST_ENV_NUMBER' ]. to_i } .yml\" end CoverageStrategy \u00b6 Uses coverage information to detect which files are covered by the given spec (i.e. the files that, if changed, may potentially break the spec); To customize the way the execution detection works, pass an object that responds to #detect and returns the paths to the strategy initialization: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: CoverageStrategy . new ( my_detector ) end By default, the execution detector is a Crystalball::MapGenerator::CoverageStrategy::ExecutionDetector , which filters out the paths outside of the project root and converts absolute paths to relative. AllocatedObjectsStrategy \u00b6 Looks for the files in which the objects allocated during the spec execution are defined. It is considerably slower than CoverageStrategy . To use this strategy, use the convenient method .build which takes two optional keyword arguments: only , used to define the classes or modules to have their descendants tracked (defaults to [] ); and root , which is the path where the detection will take place (defaults to Dir.pwd ). Here's an example that tracks allocation of ActiveRecord::Base objects: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: AllocatedObjectsStrategy . build ( only : [ 'ActiveRecord::Base' ] ) end That method is fine for most uses, but if you need to further customize the behavior of the strategy, you can directly instantiate the class. Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: AllocatedObjectsStrategy . new ( execution_detector : my_detector , object_tracker : my_tracker ) end The initialization takes two keyword arguments: execution_detector and object_tracker . execution_detector must be an object that responds to #detect receiving a list of objects and returning the paths affected by said objects. object_tracker is something that responds to #used_classes_during which yields to the caller and returns the array of classes of objects allocated during the execution of the block. DescribedClassStrategy \u00b6 This strategy will take each example that has a described_class (i.e. examples inside describe blocks of classes and not strings) and add the paths where the described class and its ancestors are defined to the example group map of the example; To use it, add to your Crystalball::MapGenerator.start! block: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: DescribedClassStrategy . new end As with AllocatedObjectsStrategy , you can pass a custom execution detector (an object that responds to #detect and returns the paths) to the initialization: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: DescribedClassStrategy . new ( my_detector ) end ParserStrategy \u00b6 The ParserStrategy , as the name suggests parses the files in order to detect which files are affected by an example. It works by first parsing all ( .rb ) files that match the given pattern under the configured root directory (defaults to current directory) to collect the constants definition paths. Then, when each example is executed, the used files of the current example group map are parsed to check for method calls to those constants. For that reason, ParserStrategy only works when used with other strategies and is placed at the end of the strategies list . To use it, add the parser gem to your Gemfile and: require 'crystalball/map_generator/parser_strategy' Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: ParserStrategy . new ( pattern : /\\A(app)|(lib)/ ) end ActionViewStrategy \u00b6 To use Rails specific strategies you must first require 'crystalball/rails' . This strategy patches ActionView::Template#compile! to map the examples to affected views. Use it as follows: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: ActionViewStrategy . new end I18nStrategy \u00b6 To use Rails specific strategies you must first require 'crystalball/rails' . Patches I18n to have access to the path where the locales are defined, so that those paths can be added to the example group map. To use it, add to your config: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: I18nStrategy . new end FactoryBotStrategy \u00b6 Tracks which factories were used during the example and add files with corresponding definitions to the example group map. To use it, add to your config: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: FactoryBotStrategy . new end Custom strategies \u00b6 You can create your own strategy and use it with the map generator. Any object that responds to #call(example_group_map, example) (where example_group_map is a Crystalball::ExampleGroupMap and example a RSpec::Core::Example ) and augmenting its list of used files using example_group_map.push(*paths_to_files) . Check out the implementation of the default strategies for examples. Keep in mind that all the strategies configured for the map generator will run for each example of your test suite, so it may slow down the generation process considerably. Debugging \u00b6 By default MapGenerator generates compact map. In case you need plain and easily readable map add to your config: Crystalball :: MapGenerator . start! do | config | #... config . compact_map = false end TablesMapGenerator \u00b6 TablesMapGenerator is a separate map generator for Rails applications. It collects information about tables-to-models mapping and stores it in a file. The file is used by Crystalball::Rails::Predictor::ModifiedSchema . Use Crystalball::Rails::TablesMapGenerator.start! to start it. By default TablesMapGenerator will generate tables_map.yml file. You can customize this behavior by setting map_storage_path variable: Crystalball :: TablesMapGenerator . start! do | config | #... config . map_storage_path = 'my_custom_tables_map_name.yml' end","title":"Map Generators"},{"location":"map_generators/#map-generators","text":"","title":"Map generators"},{"location":"map_generators/#execution-map-generator","text":"There are different map generator strategies that can (and should) be used together for better predictions. Each one has its own benefits and drawbacks, so they should be configured to best fit your needs.","title":"Execution Map Generator"},{"location":"map_generators/#custom-map-file-name","text":"You can customize resulting map filename with map_storage_path value. E.g. Crystalball :: MapGenerator . start! do | config | #... config . map_storage_path = \"execution_map_ #{ ENV [ 'TEST_ENV_NUMBER' ]. to_i } .yml\" end","title":"Custom map file name"},{"location":"map_generators/#coveragestrategy","text":"Uses coverage information to detect which files are covered by the given spec (i.e. the files that, if changed, may potentially break the spec); To customize the way the execution detection works, pass an object that responds to #detect and returns the paths to the strategy initialization: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: CoverageStrategy . new ( my_detector ) end By default, the execution detector is a Crystalball::MapGenerator::CoverageStrategy::ExecutionDetector , which filters out the paths outside of the project root and converts absolute paths to relative.","title":"CoverageStrategy"},{"location":"map_generators/#allocatedobjectsstrategy","text":"Looks for the files in which the objects allocated during the spec execution are defined. It is considerably slower than CoverageStrategy . To use this strategy, use the convenient method .build which takes two optional keyword arguments: only , used to define the classes or modules to have their descendants tracked (defaults to [] ); and root , which is the path where the detection will take place (defaults to Dir.pwd ). Here's an example that tracks allocation of ActiveRecord::Base objects: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: AllocatedObjectsStrategy . build ( only : [ 'ActiveRecord::Base' ] ) end That method is fine for most uses, but if you need to further customize the behavior of the strategy, you can directly instantiate the class. Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: AllocatedObjectsStrategy . new ( execution_detector : my_detector , object_tracker : my_tracker ) end The initialization takes two keyword arguments: execution_detector and object_tracker . execution_detector must be an object that responds to #detect receiving a list of objects and returning the paths affected by said objects. object_tracker is something that responds to #used_classes_during which yields to the caller and returns the array of classes of objects allocated during the execution of the block.","title":"AllocatedObjectsStrategy"},{"location":"map_generators/#describedclassstrategy","text":"This strategy will take each example that has a described_class (i.e. examples inside describe blocks of classes and not strings) and add the paths where the described class and its ancestors are defined to the example group map of the example; To use it, add to your Crystalball::MapGenerator.start! block: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: DescribedClassStrategy . new end As with AllocatedObjectsStrategy , you can pass a custom execution detector (an object that responds to #detect and returns the paths) to the initialization: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: DescribedClassStrategy . new ( my_detector ) end","title":"DescribedClassStrategy"},{"location":"map_generators/#parserstrategy","text":"The ParserStrategy , as the name suggests parses the files in order to detect which files are affected by an example. It works by first parsing all ( .rb ) files that match the given pattern under the configured root directory (defaults to current directory) to collect the constants definition paths. Then, when each example is executed, the used files of the current example group map are parsed to check for method calls to those constants. For that reason, ParserStrategy only works when used with other strategies and is placed at the end of the strategies list . To use it, add the parser gem to your Gemfile and: require 'crystalball/map_generator/parser_strategy' Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: ParserStrategy . new ( pattern : /\\A(app)|(lib)/ ) end","title":"ParserStrategy"},{"location":"map_generators/#actionviewstrategy","text":"To use Rails specific strategies you must first require 'crystalball/rails' . This strategy patches ActionView::Template#compile! to map the examples to affected views. Use it as follows: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: ActionViewStrategy . new end","title":"ActionViewStrategy"},{"location":"map_generators/#i18nstrategy","text":"To use Rails specific strategies you must first require 'crystalball/rails' . Patches I18n to have access to the path where the locales are defined, so that those paths can be added to the example group map. To use it, add to your config: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: I18nStrategy . new end","title":"I18nStrategy"},{"location":"map_generators/#factorybotstrategy","text":"Tracks which factories were used during the example and add files with corresponding definitions to the example group map. To use it, add to your config: Crystalball :: MapGenerator . start! do | config | #... config . register Crystalball :: MapGenerator :: FactoryBotStrategy . new end","title":"FactoryBotStrategy"},{"location":"map_generators/#custom-strategies","text":"You can create your own strategy and use it with the map generator. Any object that responds to #call(example_group_map, example) (where example_group_map is a Crystalball::ExampleGroupMap and example a RSpec::Core::Example ) and augmenting its list of used files using example_group_map.push(*paths_to_files) . Check out the implementation of the default strategies for examples. Keep in mind that all the strategies configured for the map generator will run for each example of your test suite, so it may slow down the generation process considerably.","title":"Custom strategies"},{"location":"map_generators/#debugging","text":"By default MapGenerator generates compact map. In case you need plain and easily readable map add to your config: Crystalball :: MapGenerator . start! do | config | #... config . compact_map = false end","title":"Debugging"},{"location":"map_generators/#tablesmapgenerator","text":"TablesMapGenerator is a separate map generator for Rails applications. It collects information about tables-to-models mapping and stores it in a file. The file is used by Crystalball::Rails::Predictor::ModifiedSchema . Use Crystalball::Rails::TablesMapGenerator.start! to start it. By default TablesMapGenerator will generate tables_map.yml file. You can customize this behavior by setting map_storage_path variable: Crystalball :: TablesMapGenerator . start! do | config | #... config . map_storage_path = 'my_custom_tables_map_name.yml' end","title":"TablesMapGenerator"},{"location":"predictors/","text":"Predictors \u00b6 Basic usage \u00b6 By default Crystalball uses Crystalball::RSpec::StandardPredictionBuilder which uses just two strategies for prediction ModifiedExecutionPaths and ModifiedSpecs . This is more than enough for first time use. Advanced usage \u00b6 If you want to squeeze out the most out of Crystalball you might want to add additional available prediction strategies or even add your own. To do that you should create a class inherited from Crystalball::RSpec::PredictionBuilder and overload predictor method with your custom predictor setup similar to what we have in StandardPredictionBuilder E.g. class MyPredictionBuilder < Crystalball :: RSpec :: PredictionBuilder def predictor super do | p | p . use Crystalball :: Predictor :: ModifiedSpecs . new p . use Crystalball :: Predictor :: ModifiedExecutionPaths . new p . use Crystalball :: Predictor :: ModifiedSupportSpecs . new end end end creates a predictor with additional ModifiedSupportSpecs strategy enabled. You also must let our runner know about your new prediction builder by adding it to configuration. Please see runner configuration page for details. Strategies \u00b6 AssociatedSpecs \u00b6 Needs to be configured with rules for detecting which specs should be on the prediction. predictor . use Crystalball :: Predictor :: AssociatedSpecs . new ( from : %r{models/(.*).rb} , to : \"./spec/models/%s_spec.rb\" ) will add ./spec/models/foo_spec.rb to prediction when models/foo.rb changes. This strategy does not depend on a previously generated example group map. ModifiedExecutionPaths \u00b6 Checks the example group map and the diff to see which specs are affected by the new or modified files. ModifiedSpecs \u00b6 As the name implies, checks for modified specs. The scope can be modified by passing a regex as argument, which defaults to %r{spec/.*_spec\\.rb\\z} . This strategy does not depend on a previously generated example group map. ModifiedSupportSpecs \u00b6 Checks for modified support files used in specs and predicts full spec file. The scope can be modified by passing a regex as argument, which defaults to %r{spec/support/.*\\.rb\\z} . Mostly usable for shared_contexts and shared_examples. ModifiedSchema \u00b6 Checks for modified db schema in rails application. You need to specify a path to a file with tables map generated by TablesMapGenerator . It checks schema diff to see which models are affected by modified tables and which specs are affected by this models. predictor . use Crystalball :: Rails :: Predictor :: ModifiedSchema . new ( tables_map_path : './tables_map.yml' ) Note : You may meet a warning like \"WARNING: there are no model files for changed table ...\". Usually, such tables are leftovers or a relation table for has-and-belongs-to-many associations. For the first case - nothing to worry about. For the second case - it means you want to change the default relation table. Custom strategies \u00b6 As with the map generator you may define custom strategies for prediction. It must be an object that responds to #call(diff, example_group_map) (where diff is a Crystalball::SourceDiff and example_group_map is a Crystalball::ExampleGroupMap ) and returns an array of paths. Check out default strategies implementation for examples.","title":"Predictors"},{"location":"predictors/#predictors","text":"","title":"Predictors"},{"location":"predictors/#basic-usage","text":"By default Crystalball uses Crystalball::RSpec::StandardPredictionBuilder which uses just two strategies for prediction ModifiedExecutionPaths and ModifiedSpecs . This is more than enough for first time use.","title":"Basic usage"},{"location":"predictors/#advanced-usage","text":"If you want to squeeze out the most out of Crystalball you might want to add additional available prediction strategies or even add your own. To do that you should create a class inherited from Crystalball::RSpec::PredictionBuilder and overload predictor method with your custom predictor setup similar to what we have in StandardPredictionBuilder E.g. class MyPredictionBuilder < Crystalball :: RSpec :: PredictionBuilder def predictor super do | p | p . use Crystalball :: Predictor :: ModifiedSpecs . new p . use Crystalball :: Predictor :: ModifiedExecutionPaths . new p . use Crystalball :: Predictor :: ModifiedSupportSpecs . new end end end creates a predictor with additional ModifiedSupportSpecs strategy enabled. You also must let our runner know about your new prediction builder by adding it to configuration. Please see runner configuration page for details.","title":"Advanced usage"},{"location":"predictors/#strategies","text":"","title":"Strategies"},{"location":"predictors/#associatedspecs","text":"Needs to be configured with rules for detecting which specs should be on the prediction. predictor . use Crystalball :: Predictor :: AssociatedSpecs . new ( from : %r{models/(.*).rb} , to : \"./spec/models/%s_spec.rb\" ) will add ./spec/models/foo_spec.rb to prediction when models/foo.rb changes. This strategy does not depend on a previously generated example group map.","title":"AssociatedSpecs"},{"location":"predictors/#modifiedexecutionpaths","text":"Checks the example group map and the diff to see which specs are affected by the new or modified files.","title":"ModifiedExecutionPaths"},{"location":"predictors/#modifiedspecs","text":"As the name implies, checks for modified specs. The scope can be modified by passing a regex as argument, which defaults to %r{spec/.*_spec\\.rb\\z} . This strategy does not depend on a previously generated example group map.","title":"ModifiedSpecs"},{"location":"predictors/#modifiedsupportspecs","text":"Checks for modified support files used in specs and predicts full spec file. The scope can be modified by passing a regex as argument, which defaults to %r{spec/support/.*\\.rb\\z} . Mostly usable for shared_contexts and shared_examples.","title":"ModifiedSupportSpecs"},{"location":"predictors/#modifiedschema","text":"Checks for modified db schema in rails application. You need to specify a path to a file with tables map generated by TablesMapGenerator . It checks schema diff to see which models are affected by modified tables and which specs are affected by this models. predictor . use Crystalball :: Rails :: Predictor :: ModifiedSchema . new ( tables_map_path : './tables_map.yml' ) Note : You may meet a warning like \"WARNING: there are no model files for changed table ...\". Usually, such tables are leftovers or a relation table for has-and-belongs-to-many associations. For the first case - nothing to worry about. For the second case - it means you want to change the default relation table.","title":"ModifiedSchema"},{"location":"predictors/#custom-strategies","text":"As with the map generator you may define custom strategies for prediction. It must be an object that responds to #call(diff, example_group_map) (where diff is a Crystalball::SourceDiff and example_group_map is a Crystalball::ExampleGroupMap ) and returns an array of paths. Check out default strategies implementation for examples.","title":"Custom strategies"},{"location":"runner/","text":"RSpec Runner \u00b6 Crystalball has a custom RSpec runner you can use in your development with bundle exec crystalball command. It builds a prediction and runs it. Runner Configuration \u00b6 Config file \u00b6 Create a YAML file for the runner. Default locations are ./crystalball.yml and ./config/crystalball.yml . Please check an example of a config file and configuration defaults for available options. Please keep in mind that additional generator\\prediction strategies can introduce additional configuration options. Overriding config file \u00b6 If you want to override the path to config file please set CRYSTALBALL_CONFIG=path/to/crystalball.yml env variable. Any specific configuration option in crystalball.yml can be overridden by providing ENV variable with \"CRYSTALBALL_\" prefix. E.g. CRYSTALBALL_EXAMPLES_LIMIT=10 will set examples_limit value to 10 regardless of what you have in config file. More examples: CRYSTALBALL_EXAMPLES_LIMIT=0 sets no limit on prediction size CRYSTALBALL_MAP_EXPIRATION_PERIOD=0 sets no expiration period for maps CRYSTALBALL_DIFF_FROM=origin/master changes diff building to be git diff origin/master","title":"Runner"},{"location":"runner/#rspec-runner","text":"Crystalball has a custom RSpec runner you can use in your development with bundle exec crystalball command. It builds a prediction and runs it.","title":"RSpec Runner"},{"location":"runner/#runner-configuration","text":"","title":"Runner Configuration"},{"location":"runner/#config-file","text":"Create a YAML file for the runner. Default locations are ./crystalball.yml and ./config/crystalball.yml . Please check an example of a config file and configuration defaults for available options. Please keep in mind that additional generator\\prediction strategies can introduce additional configuration options.","title":"Config file"},{"location":"runner/#overriding-config-file","text":"If you want to override the path to config file please set CRYSTALBALL_CONFIG=path/to/crystalball.yml env variable. Any specific configuration option in crystalball.yml can be overridden by providing ENV variable with \"CRYSTALBALL_\" prefix. E.g. CRYSTALBALL_EXAMPLES_LIMIT=10 will set examples_limit value to 10 regardless of what you have in config file. More examples: CRYSTALBALL_EXAMPLES_LIMIT=0 sets no limit on prediction size CRYSTALBALL_MAP_EXPIRATION_PERIOD=0 sets no expiration period for maps CRYSTALBALL_DIFF_FROM=origin/master changes diff building to be git diff origin/master","title":"Overriding config file"}]}